// auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ClientType } from '@common/enums/client-type.enum';
import { AuthRepository } from './repositories/auth.repository';
import { LocalLoginDto, SocialLoginDto } from '@auth/dto';
import { MembersService } from '@members/members.service';
import * as bcrypt from 'bcrypt';

export class RefreshTokenExpiredException extends UnauthorizedException {
 constructor() {
   super('리프레시 토큰이 만료되었습니다.');
 }
}

export class InvalidRefreshTokenException extends UnauthorizedException {
 constructor() {
   super('유효하지 않은 리프레시 토큰입니다.');
 }
}

// DB 작업용 (내부용)
interface AuthUser {
 id: number;
 uuid: string;
 email: string;
 role: string;
 preferences: {
  language: string;
  timezone: string;
  theme: string;
 };
}

// JWT Payload용 (외부용)
interface JwtPayload {
 email: string;
 sub: string;    // uuid
 role: string;
 preferences: {   // 객체 전체를 포함
  language: string;
  timezone: string;
  theme: string;
};
}

@Injectable()
export class AuthService {
 constructor(
   private readonly authRepository: AuthRepository,
   private readonly jwtService: JwtService,
   private readonly membersService: MembersService,
 ) {}

 async login(user: AuthUser, clientType: ClientType) {
   // JWT에는 외부용 정보만 포함
   const payload: JwtPayload = { 
     email: user.email, 
     sub: user.uuid,
     role: user.role,
     preferences: {
       language: user.preferences.language,
       timezone: user.preferences.timezone,
       theme: user.preferences.theme
     }
   };
   
   const accessToken = await this.jwtService.signAsync(payload, {
     expiresIn: '15m',
   });
   const refreshToken = await this.jwtService.signAsync(payload, {
     expiresIn: '7d',
   });

   // id는 DB 조회용으로만 사용
   await this.authRepository.saveRefreshToken(user.id, refreshToken);

   return {
     access_token: accessToken,
     ...(clientType === ClientType.MOBILE && { refresh_token: refreshToken }),
     refresh_token: refreshToken,
   };
 }

 async refreshAccessToken(refreshToken: string, clientType: ClientType) {
   console.log('Refresh token received:', refreshToken);
   
   // 토큰 유효성 검증
   try {
     const verified = await this.jwtService.verifyAsync(refreshToken);
     console.log('Token verified:', verified);
   } catch (e) {
     console.error('Token verification failed:', e);
     const tokenData = await this.authRepository.findByRefreshToken(refreshToken);
     if (tokenData) {
       await this.authRepository.revokeAllRefreshTokens(tokenData.member.id);
     }
     throw new RefreshTokenExpiredException();
   }

   const tokenData = await this.authRepository.findByRefreshToken(refreshToken);
   console.log('Token data from DB:', tokenData);
   
   if (!tokenData || tokenData.revoked) {
     throw new InvalidRefreshTokenException();
   }

   const payload: JwtPayload = { 
     email: tokenData.member.email, 
     sub: tokenData.member.uuid,
     role: tokenData.member.role,
     preferences: {
       language: tokenData.member.preferences.language,
       timezone: tokenData.member.preferences.timezone,
       theme: tokenData.member.preferences.theme
     }
   };
   const accessToken = await this.jwtService.signAsync(payload, {
     expiresIn: '15m',
   });
   const newRefreshToken = await this.jwtService.signAsync(payload, {
     expiresIn: '7d',
   });

   // 기존 토큰 무효화하고 새 토큰 저장
   await this.authRepository.revokeRefreshToken(refreshToken);
   await this.authRepository.saveRefreshToken(tokenData.member.id, newRefreshToken);

   return {
     access_token: accessToken,
     ...(clientType === ClientType.MOBILE && { refresh_token: newRefreshToken }),
     refresh_token: newRefreshToken,
   };
 }

 async logout(refreshToken: string, userUuid: string) {
   console.log('Attempting logout with:', { userUuid });
   const tokenData = await this.authRepository.findByRefreshToken(refreshToken);
   console.log('Token data:', tokenData);
   
   if (!tokenData || tokenData.member.uuid !== userUuid) {
     console.log('Token validation failed:', {
       tokenExists: !!tokenData,
       tokenMemberUuid: tokenData?.member?.uuid,
       requestUserUuid: userUuid
     });
     throw new InvalidRefreshTokenException();
   }

   await this.authRepository.revokeRefreshToken(refreshToken);
 }

 async logoutAll(userUuid: string) {
   const member = await this.authRepository.findByUuid(userUuid);
   if (!member) {
     throw new UnauthorizedException('사용자를 찾을 수 없습니다.');
   }

   await this.authRepository.revokeAllRefreshTokens(member.id);
 }

 async validateMember(email: string, password: string): Promise<AuthUser | null> {
   const user = await this.authRepository.findByEmail(email);
   if (!user) return null;

   // 계정 잠금 확인
   if (user.lockoutUntil && user.lockoutUntil > new Date()) {
     throw new UnauthorizedException('계정이 잠겼습니다. 잠시 후 다시 시도해주세요.');
   }

   const isPasswordValid = await bcrypt.compare(password, user.password);
   if (!isPasswordValid) {
     await this.membersService.incrementLoginAttempts(email);
     throw new UnauthorizedException('이메일 또는 비밀번호가 올바르지 않습니다.');
   }

   await this.membersService.resetLoginAttempts(email);
   
   return {
     id: user.id,
     uuid: user.uuid,
     email: user.email,
     role: user.role || 'USER',
     preferences: user.preferences || {
       language: 'ko',
       timezone: 'Asia/Seoul',
       theme: 'light'
     }
   } as AuthUser;
 }

  // private async validateSocialToken(accessToken: string, provider: AuthProvider) {
  //   // 소셜 토큰 검증 및 프로필 조회 로직
  //   // 각 provider별 구현 필요
  // }
}

